<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>Resolving values for unmapped properties when mapping request data to DTOs in Symfony 6.3+</title>
  <meta name="description" content="Ever since it was introduced,the functionality for mapping request data to DTOs has been my favourite Symfony 6.3 new feature. The new #[MapRequestPayload] a...">

	
  		<meta content="article" property="og:type">
	
	<meta property="og:title" content="Resolving values for unmapped properties when mapping request data to DTOs in Symfony 6.3+" />
	<meta property="og:description" content="Ever since it was introduced,the functionality for mapping request data to DTOs has been my favourite Symfony 6.3 new feature. The new #[MapRequestPayload] a..." />
	
  		<meta content="http://angelovdejan.me/2023/06/01/resolving-values-for-unmapped-properties-when-mapping-request-data-to-dtos-in-symfony-6-3.html" property="og:url">
	
	<meta property="og:site_name" content="Dejan Angelov" />
	<meta property="og:image" content="http://angelovdejan.me/images/pexels-daria-obymaha-1684149.jpg" />
	<meta name="twitter:site" content="@angelovdejan" />

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://angelovdejan.me/2023/06/01/resolving-values-for-unmapped-properties-when-mapping-request-data-to-dtos-in-symfony-6-3.html">
  <link rel="alternate" type="application/atom+xml" title="Dejan Angelov" href="http://angelovdejan.me/feed.xml" />
  <link rel="me" href="https://phpc.social/@angelov">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Dejan Angelov</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
          <a class="page-link" href="/">Blog</a>
        
          
          <a class="page-link" href="/about/">About Me</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Resolving values for unmapped properties when mapping request data to DTOs in Symfony 6.3+</h1>
    <p class="post-meta">Jun 1, 2023 • Dejan Angelov</p>
  </header>

  <article class="post-content">
    <p>Ever since it was <a href="https://symfony.com/blog/new-in-symfony-6-3-mapping-request-data-to-typed-objects" target="_blank">introduced</a>,
the functionality for mapping request data to DTOs has been my favourite Symfony 6.3 new feature. The new 
<code class="language-plaintext highlighter-rouge">#[MapRequestPayload]</code> and <code class="language-plaintext highlighter-rouge">#[MapQueryString]</code> attributes allow us to delegate the DTO instantiation to the framework, 
instead of doing it manually in the controllers - for example when instantiating commands to be dispatched to a command 
bus. However, I realized that most of the commands in my application contain additional properties which are not 
directly mapped to the request data - such as the ID of the currently authenticated user. In this article, we’ll see how
we can enhance the process to be able to resolve the unmapped values in such cases.</p>

<p>Let’s start with this command:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="k">readonly</span> <span class="kd">class</span> <span class="nc">ReserveRoomCommand</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">__construct</span><span class="p">(</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="nv">$customerId</span><span class="p">,</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="nv">$roomId</span><span class="p">,</span>
        <span class="k">public</span> <span class="kt">DateTimeImmutable</span> <span class="nv">$reservationFrom</span><span class="p">,</span>
        <span class="k">public</span> <span class="kt">DateTimeImmutable</span> <span class="nv">$reservationTo</span>
    <span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Usually, when we want to dispatch an instance of the command from a controller, we’d manually retrieve the values from 
the request object, and use them to initiate the command object:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="na">#[Route("/reservations")]</span>
<span class="kd">class</span> <span class="nc">ReservationsController</span> <span class="kd">extends</span> <span class="nc">AbstractController</span>
<span class="p">{</span>
    <span class="na">#[Route("/", methods: "POST")]</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">reserve</span><span class="p">(</span><span class="kt">Request</span> <span class="nv">$request</span><span class="p">):</span> <span class="kt">Response</span>
    <span class="p">{</span>
        <span class="nv">$command</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReserveRoomCommand</span><span class="p">(</span>
            <span class="nv">$request</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="nf">get</span><span class="p">(</span><span class="s1">'customerId'</span><span class="p">),</span>
            <span class="nv">$request</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="nf">get</span><span class="p">(</span><span class="s1">'roomId'</span><span class="p">),</span>
            <span class="k">new</span> <span class="nc">\DateTimeImmutable</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="nf">get</span><span class="p">(</span><span class="s1">'from'</span><span class="p">)),</span>
            <span class="k">new</span> <span class="nc">\DateTimeImmutable</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="nf">get</span><span class="p">(</span><span class="s1">'to'</span><span class="p">))</span>
        <span class="p">)</span>

        <span class="c1">// ... dispatch the command, etc.</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>With the new <code class="language-plaintext highlighter-rouge">#[MapRequestPayload]</code> attribute provided by Symfony, this process is now automated, and we can replace the
<code class="language-plaintext highlighter-rouge">Request</code> argument of the controller method with an argument of the command class. Additionally, we need to declare the
new attribute on the argument.</p>

<div class="alert alert-info">
    <small>
	    <strong>Note:</strong>
        We will only use <code>#[MapRequestPayload]</code> in this article, but the same applies when using the 
        <code>#[MapQueryString]</code> attribute too. The framework uses the same value resolver for attributes with 
        any of these attributes.
    </small>
</div>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="na">#[Route("/reservations")]</span>
<span class="kd">class</span> <span class="nc">ReservationsController</span> <span class="kd">extends</span> <span class="nc">AbstractController</span>
<span class="p">{</span>
    <span class="na">#[Route("/", methods: "POST")]</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">reserve</span><span class="p">(</span>
        <span class="err">#</span><span class="p">[</span><span class="nc">MapRequestPayload</span><span class="p">]</span> <span class="nc">ReserveRoomCommand</span> <span class="nv">$command</span>
    <span class="p">)</span><span class="o">:</span> <span class="nc">Response</span> <span class="p">{</span>
        <span class="c1">// ... dispatch the command, etc.</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>So, the framework will instantiate the object for us and populate it with the data from the request. But what if we 
don’t want to read the <code class="language-plaintext highlighter-rouge">customerId</code> value form the request, but use the ID of the authenticated customer instead?</p>

<p>Although customizable, by default the framework uses the 
<code class="language-plaintext highlighter-rouge">\Symfony\Component\HttpKernel\Controller\ArgumentResolver\RequestPayloadValueResolver</code>
<a href="https://symfony.com/doc/6.3/controller/value_resolver.html">value resolver</a> when resolving controller action arguments 
like the command object above.</p>

<p>If we take a look at that resolver, we can see that it simply reads the request content (either from the query string 
or the payload) and passes it to the Serializer component. The serializer decodes the data if needed (e.g. if the 
data is sent as a JSON object) - turning it into an associative array, and then denormalizes it - turning it into an 
object of the desired class, in our case <code class="language-plaintext highlighter-rouge">ReseveRoomCommand</code>.</p>

<p>In our case, the <code class="language-plaintext highlighter-rouge">customerId</code> property of the command doesn’t have a default value, so if we don’t supply it within the 
request, the denormalization process will fail.</p>

<blockquote>
  <p>Failed to create object because the class misses the “customerId” property.<br />
<sup>PartialDenormalizationException</sup></p>
</blockquote>

<p>To avoid this, but to also protect the value from being set from outside, we’ll need to hook into the denormalization 
process and modify the data by adding/replacing the needed items.</p>

<p>First, let’s create a new denormalizer.</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="kn">use</span> <span class="nc">Symfony\Component\Serializer\Normalizer\DenormalizerInterface</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">PropertyValueResolvingDenormalizer</span> <span class="kd">implements</span> <span class="nc">DenormalizerInterface</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">denormalize</span><span class="p">(</span><span class="kt">mixed</span> <span class="nv">$data</span><span class="p">,</span> <span class="kt">string</span> <span class="nv">$type</span><span class="p">,</span> <span class="kt">string</span> <span class="nv">$format</span> <span class="o">=</span> <span class="kc">null</span><span class="p">,</span> <span class="kt">array</span> <span class="nv">$context</span> <span class="o">=</span> <span class="p">[]):</span> <span class="kt">mixed</span> <span class="p">{</span> <span class="mf">...</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="n">supportsDenormalization</span><span class="p">(</span><span class="kt">mixed</span> <span class="nv">$data</span><span class="p">,</span> <span class="kt">string</span> <span class="nv">$type</span><span class="p">,</span> <span class="kt">string</span> <span class="nv">$format</span> <span class="o">=</span> <span class="kc">null</span><span class="p">):</span> <span class="kt">bool</span> <span class="p">{</span> <span class="mf">...</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="n">getSupportedTypes</span><span class="p">(</span><span class="kt">?string</span> <span class="nv">$format</span><span class="p">):</span> <span class="kt">array</span> <span class="p">{</span> <span class="mf">...</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We only want to resolve values for some properties, and not all of them can be resolved in the same way. To achieve the
differentiation, we can create new (or reuse some existing) custom attributes for each case, e.g. for resolving the ID
of the authenticated customer.</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="na">#[\Attribute(\Attribute::TARGET_PROPERTY)]</span>
<span class="kd">class</span> <span class="nc">Authenticated</span>
<span class="p">{</span>
<span class="p">}</span></code></pre></figure>

<p>And declare it on the argument in the command:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="k">readonly</span> <span class="kd">class</span> <span class="nc">ReserveRoomCommand</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">__construct</span><span class="p">(</span>
        <span class="err">#</span><span class="p">[</span><span class="nc">Authenticated</span><span class="p">]</span> <span class="k">public</span> <span class="kt">string</span> <span class="nv">$customerId</span><span class="p">,</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="nv">$roomId</span><span class="p">,</span>
        <span class="k">public</span> <span class="kt">DateTimeImmutable</span> <span class="nv">$from</span><span class="p">,</span>
        <span class="k">public</span> <span class="kt">DateTimeImmutable</span> <span class="nv">$to</span><span class="p">,</span>
    <span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>As already mentioned, we can have multiple similar attributes and multiple ways for resolving values, so we can define 
the following interface and have all the resolves implement it:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="kn">use</span> <span class="nc">Symfony\Component\DependencyInjection\Attribute\AutoconfigureTag</span><span class="p">;</span>

<span class="na">#[AutoconfigureTag]</span>
<span class="kd">interface</span> <span class="nc">PropertyValueResolverInterface</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">resolve</span><span class="p">(</span><span class="kt">ReflectionAttribute</span> <span class="nv">$attribute</span><span class="p">):</span> <span class="kt">mixed</span><span class="p">;</span>

    <span class="cd">/** @return class-string */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">supportedAttribute</span><span class="p">():</span> <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<div class="alert alert-info">
    <small>
	    <strong>Note:</strong> For simplicity, we'll use attributes to interact with the Symfony's Dependency Injection
        container. You can still use your preferred way for configuring it.
    </small>
</div>

<p>To resolve values for arguments marked with our <code class="language-plaintext highlighter-rouge">#[Authenticated]</code> attribute, we’ll have an implementation that will 
support that attribute, and which will be fetching the current customer and returning its ID.</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="kd">class</span> <span class="nc">AuthenticatedUserResolver</span> <span class="kd">implements</span> <span class="nc">PropertyValueResolverInterface</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">public</span> <span class="k">function</span> <span class="n">resolve</span><span class="p">(</span><span class="kt">ReflectionAttribute</span> <span class="nv">$attribute</span><span class="p">):</span> <span class="kt">mixed</span>
    <span class="p">{</span>
        <span class="nv">$uuid</span> <span class="o">=</span> <span class="c1">// resolve the authenticated customer's uuid using some other service</span>

        <span class="k">return</span> <span class="nv">$uuid</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="n">supportedAttribute</span><span class="p">():</span> <span class="kt">string</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nc">Authenticated</span><span class="o">::</span><span class="n">class</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Back to the denormalizer, we’ll be injecting an array of all registered value resolvers implementing the interface from 
above. Then in the <code class="language-plaintext highlighter-rouge">supportsDenormalization</code> we can use this list to determine if the denormalizer should be applied 
when mapping some request data.</p>

<p>Among the other arguments we’re receiving in the <code class="language-plaintext highlighter-rouge">supportsDenormalization</code> method is the type i.e. the class of the 
object we’ll be getting at the end of the process - in our case the command. From that class, we can get the list of 
properties and then iterate over it to find if any of the properties has a declared attribute for which we have a 
suitable value resolver. If we find such property, we’ll let the serializer know that it should use this denormalizer.</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="kn">use</span> <span class="nc">Symfony\Component\DependencyInjection\Attribute\TaggedIterator</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">Symfony\Component\Serializer\Normalizer\DenormalizerInterface</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">PropertyValueResolvingDenormalizer</span> <span class="kd">implements</span> <span class="nc">DenormalizerInterface</span>
<span class="p">{</span>
    <span class="cd">/** @var array&lt;class-string, object&lt;PropertyValueResolverInterface&gt;&gt; */</span>
    <span class="k">private</span> <span class="kt">array</span> <span class="nv">$resolvers</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="cd">/** @param iterable&lt;PropertyValueResolverInterface&gt; $resolvers */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">__construct</span><span class="p">(</span>
        <span class="err">#</span><span class="p">[</span><span class="nf">TaggedIterator</span><span class="p">(</span><span class="nc">PropertyValueResolverInterface</span><span class="o">::</span><span class="n">class</span><span class="p">)]</span> <span class="n">iterable</span> <span class="nv">$resolvers</span>
    <span class="p">){</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="nv">$resolvers</span> <span class="k">as</span> <span class="nv">$resolver</span><span class="p">)</span> <span class="p">{</span>
            <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">resolvers</span><span class="p">[</span><span class="nv">$resolver</span><span class="o">-&gt;</span><span class="nf">supportedAttribute</span><span class="p">()]</span> <span class="o">=</span> <span class="nv">$resolver</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="n">supportsDenormalization</span><span class="p">(</span><span class="kt">mixed</span> <span class="nv">$data</span><span class="p">,</span> <span class="kt">string</span> <span class="nv">$type</span><span class="p">,</span> <span class="kt">string</span> <span class="nv">$format</span> <span class="o">=</span> <span class="kc">null</span><span class="p">):</span> <span class="kt">bool</span>
    <span class="p">{</span>
        <span class="nv">$properties</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="nc">ReflectionClass</span><span class="p">(</span><span class="nv">$type</span><span class="p">))</span><span class="o">-&gt;</span><span class="nf">getProperties</span><span class="p">();</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="nv">$properties</span> <span class="k">as</span> <span class="nv">$property</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">canResolveValueForProperty</span><span class="p">(</span><span class="nv">$property</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">function</span> <span class="n">canResolveValueForProperty</span><span class="p">(</span><span class="kt">ReflectionProperty</span> <span class="nv">$property</span><span class="p">):</span> <span class="kt">bool</span>
    <span class="p">{</span>
        <span class="nv">$attributes</span> <span class="o">=</span> <span class="nv">$property</span><span class="o">-&gt;</span><span class="nf">getAttributes</span><span class="p">();</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="nv">$attributes</span> <span class="k">as</span> <span class="nv">$attribute</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">array_key_exists</span><span class="p">(</span><span class="nv">$attribute</span><span class="o">-&gt;</span><span class="nf">getName</span><span class="p">(),</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">resolvers</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>In the <code class="language-plaintext highlighter-rouge">denormalize</code> method we’ll be doing something similar - we can iterate over the class’s properties as we did 
above, and use a suitable value resolver for each of the properties that need resolving. In the <code class="language-plaintext highlighter-rouge">data</code> argument we’ll 
have the existing request data - which have previously been decoded by the serializer - as an array that we can modify 
to add/replace the resolved values.</p>

<p>As our intention is not to completely replace the denormalization process, but just to enhance it, we’ll pass the final
modified data array to the serializer’s <code class="language-plaintext highlighter-rouge">ObjectNormalizer</code> which will then transform it into an object.</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="kn">use</span> <span class="nc">Symfony\Component\Serializer\Normalizer\DenormalizerInterface</span><span class="p">;</span>
<span class="kn">use</span> <span class="nc">Symfony\Component\Serializer\Normalizer\ObjectNormalizer</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">PropertyValueResolvingDenormalizer</span> <span class="kd">implements</span> <span class="nc">DenormalizerInterface</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">private</span> <span class="kt">ObjectNormalizer</span> <span class="nv">$objectNormalizer</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="n">__construct</span><span class="p">(</span>
        <span class="c1">// ...</span>
        <span class="kt">ObjectNormalizer</span> <span class="nv">$objectNormalizer</span><span class="p">,</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">objectNormalizer</span> <span class="o">=</span> <span class="nv">$objectNormalizer</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="n">denormalize</span><span class="p">(</span><span class="kt">mixed</span> <span class="nv">$data</span><span class="p">,</span> <span class="kt">string</span> <span class="nv">$type</span><span class="p">,</span> <span class="kt">string</span> <span class="nv">$format</span> <span class="o">=</span> <span class="kc">null</span><span class="p">,</span> <span class="kt">array</span> <span class="nv">$context</span> <span class="o">=</span> <span class="p">[]):</span> <span class="kt">mixed</span>
    <span class="p">{</span>
        <span class="nv">$properties</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="nc">ReflectionClass</span><span class="p">(</span><span class="nv">$type</span><span class="p">))</span><span class="o">-&gt;</span><span class="nf">getProperties</span><span class="p">();</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="nv">$properties</span> <span class="k">as</span> <span class="nv">$property</span><span class="p">)</span> <span class="p">{</span>
            <span class="nv">$name</span> <span class="o">=</span> <span class="nv">$property</span><span class="o">-&gt;</span><span class="nf">getName</span><span class="p">();</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">canResolveValueForProperty</span><span class="p">(</span><span class="nv">$property</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// shown in code above</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="nv">$data</span><span class="p">[</span><span class="nv">$name</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="nf">resolveValueForProperty</span><span class="p">(</span><span class="nv">$property</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">objectNormalizer</span><span class="o">-&gt;</span><span class="nf">denormalize</span><span class="p">(</span><span class="nv">$data</span><span class="p">,</span> <span class="nv">$type</span><span class="p">,</span> <span class="nv">$format</span><span class="p">,</span> <span class="nv">$context</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">function</span> <span class="n">resolveValueForProperty</span><span class="p">(</span><span class="kt">ReflectionProperty</span> <span class="nv">$property</span><span class="p">):</span> <span class="kt">mixed</span>
    <span class="p">{</span>
        <span class="nv">$attributes</span> <span class="o">=</span> <span class="nv">$property</span><span class="o">-&gt;</span><span class="nf">getAttributes</span><span class="p">();</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="nv">$attributes</span> <span class="k">as</span> <span class="nv">$attribute</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">array_key_exists</span><span class="p">(</span><span class="nv">$attribute</span><span class="o">-&gt;</span><span class="nf">getName</span><span class="p">(),</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">resolvers</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">resolvers</span><span class="p">[</span><span class="nv">$attribute</span><span class="o">-&gt;</span><span class="nf">getName</span><span class="p">()]</span><span class="o">-&gt;</span><span class="nf">resolve</span><span class="p">(</span><span class="nv">$attribute</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Finally, let’s also look at the <code class="language-plaintext highlighter-rouge">getSupportedTypes</code> method. It has been introduced in Symfony 6.3 too as a performance 
improvement, but due to BC reasons is still not enforced as part of the <code class="language-plaintext highlighter-rouge">DenormalizerInterface</code> interface. It is also a 
replacement for the now-deprecated <code class="language-plaintext highlighter-rouge">\Symfony\Component\Serializer\Normalizer\CacheableSupportsMethodInterface</code> interface 
and can be used to tell the serializer whether it can cache the result of the <code class="language-plaintext highlighter-rouge">supportsDenormalization</code> method when 
denormalizing into a certain type.</p>

<p>As our denormalizer can process data for multiple types - objects of multiple classes, and the declared attributes are 
not changing during the execution, we can use the generic <code class="language-plaintext highlighter-rouge">object</code> type and always allow the caching.</p>

<p>You can read more about the <code class="language-plaintext highlighter-rouge">getSupportedTypes</code> in 
<a href="https://symfony.com/blog/new-in-symfony-6-3-performance-improvements#improved-performance-of-serializer-normalizers-denormalizers" target="_blank">this article</a>.</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="kn">use</span> <span class="nc">Symfony\Component\Serializer\Normalizer\DenormalizerInterface</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">PropertyValueResolvingDenormalizer</span> <span class="kd">implements</span> <span class="nc">DenormalizerInterface</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="cd">/** @return array&lt;class-string, bool&gt; */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">getSupportedTypes</span><span class="p">(</span><span class="kt">?string</span> <span class="nv">$format</span><span class="p">):</span> <span class="kt">array</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">'object'</span> <span class="o">=&gt;</span> <span class="kc">true</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><small><small>
<em>The whole PropertyValueResolvingDenormalizer class is available
<a href="https://gist.github.com/angelov/9f0beae2c415771931ab9221212a1b5f" target="_blank">here</a>.</em>
</small></small></p>

<p>To try the denormalizer out, let’s say that the ID of the authenticated customer is “customer-uuid”. If we send a 
request with the following JSON body to our endpoint:</p>

<figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nl">"roomId"</span><span class="p">:</span><span class="w"> </span><span class="s2">"room-uuid"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"from"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2023-06-10"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"to"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2023-06-15"</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>We’ll get the following object as a result:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="o">^</span> <span class="nc">ReserveRoomCommand</span> <span class="p">{</span><span class="c1">#181</span>
    <span class="o">+</span><span class="n">customerId</span><span class="o">:</span> <span class="s2">"customer-uuid"</span>
    <span class="o">+</span><span class="n">roomId</span><span class="o">:</span> <span class="s2">"room-uuid"</span>
    <span class="o">+</span><span class="n">from</span><span class="o">:</span> <span class="nc">DateTimeImmutable</span> <span class="o">@</span><span class="mi">1686355200</span> <span class="p">{</span><span class="c1">#182</span>
        <span class="n">date</span><span class="o">:</span> <span class="mi">2023</span><span class="o">-</span><span class="mo">06</span><span class="o">-</span><span class="mi">10</span> <span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mf">00.0</span> <span class="nf">UTC</span> <span class="p">(</span><span class="o">+</span><span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">+</span><span class="n">to</span><span class="o">:</span> <span class="nc">DateTimeImmutable</span> <span class="o">@</span><span class="mi">1686787200</span> <span class="p">{</span><span class="c1">#209</span>
        <span class="n">date</span><span class="o">:</span> <span class="mi">2023</span><span class="o">-</span><span class="mo">06</span><span class="o">-</span><span class="mi">15</span> <span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mf">00.0</span> <span class="nf">UTC</span> <span class="p">(</span><span class="o">+</span><span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>As another example, let’s imagine that for some reason we also want to pass the reservation time within the command, 
which will be the current time.</p>

<p>Now we just need to create a new (or re-use an existing) attribute:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="na">#[\Attribute(\Attribute::TARGET_PROPERTY)]</span>
<span class="kd">class</span> <span class="nc">CurrentDateTime</span>
<span class="p">{</span>
<span class="p">}</span></code></pre></figure>

<p>And a resolver for it:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="kn">use</span> <span class="nc">Psr\Clock\ClockInterface</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">CurrentDateTimeResolver</span> <span class="kd">implements</span> <span class="nc">PropertyValueResolverInterface</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="kt">ClockInterface</span> <span class="nv">$clock</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="n">__construct</span><span class="p">(</span><span class="kt">ClockInterface</span> <span class="nv">$clock</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">clock</span> <span class="o">=</span> <span class="nv">$clock</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="n">resolve</span><span class="p">(</span><span class="kt">ReflectionAttribute</span> <span class="nv">$attribute</span><span class="p">):</span> <span class="kt">mixed</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="n">clock</span><span class="o">-&gt;</span><span class="nf">now</span><span class="p">()</span><span class="o">-&gt;</span><span class="nf">format</span><span class="p">(</span><span class="no">DATE_ATOM</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="n">supportedAttribute</span><span class="p">():</span> <span class="kt">string</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nc">CurrentDateTime</span><span class="o">::</span><span class="n">class</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Note that here we’re returning a string as a resolved value, and not a <code class="language-plaintext highlighter-rouge">DateTimeImmutable</code> object. That’s because after 
we pass the data to the <code class="language-plaintext highlighter-rouge">ObjectNormalizer</code> to continue with the denormalization, it will use the 
<code class="language-plaintext highlighter-rouge">\Symfony\Component\Serializer\Normalizer\DateTimeNormalizer</code> denormalizer to instantiate the final <code class="language-plaintext highlighter-rouge">DateTimeImmmutable</code> 
object - and that denormalizer requires the value to be sent as a string. So, in general, our value resolvers should 
be returning the resolved values just as if they’ve been send within a request.</p>

<p>Now if we add a new property to the command and declare the attribute on it:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="k">readonly</span> <span class="kd">class</span> <span class="nc">ReserveRoomCommand</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="n">__construct</span><span class="p">(</span>
        <span class="err">#</span><span class="p">[</span><span class="nc">Authenticated</span><span class="p">]</span> <span class="k">public</span> <span class="kt">string</span> <span class="nv">$customerId</span><span class="p">,</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="nv">$roomId</span><span class="p">,</span>
        <span class="k">public</span> <span class="kt">DateTimeImmutable</span> <span class="nv">$from</span><span class="p">,</span>
        <span class="k">public</span> <span class="kt">DateTimeImmutable</span> <span class="nv">$to</span><span class="p">,</span>
        <span class="err">#</span><span class="p">[</span><span class="nc">CurrentDateTime</span><span class="p">]</span> <span class="k">public</span> <span class="kt">DateTimeImmutable</span> <span class="nv">$reservedAt</span>
    <span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>When we send the same JSON object as a request as above, we’ll get the current time as expected:</p>

<figure class="highlight"><pre><code class="language-php" data-lang="php"><span class="o">^</span> <span class="nc">ReserveRoomCommand</span> <span class="p">{</span><span class="c1">#184</span>
    <span class="o">+</span><span class="n">customerId</span><span class="o">:</span> <span class="s2">"customer-uuid"</span>
    <span class="o">+</span><span class="n">roomId</span><span class="o">:</span> <span class="s2">"room-uuid"</span>
    <span class="o">+</span><span class="n">from</span><span class="o">:</span> <span class="nc">DateTimeImmutable</span> <span class="o">@</span><span class="mi">1686355200</span> <span class="p">{</span><span class="c1">#185</span>
        <span class="n">date</span><span class="o">:</span> <span class="mi">2023</span><span class="o">-</span><span class="mo">06</span><span class="o">-</span><span class="mi">10</span> <span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mf">00.0</span> <span class="nf">UTC</span> <span class="p">(</span><span class="o">+</span><span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">+</span><span class="n">to</span><span class="o">:</span> <span class="nc">DateTimeImmutable</span> <span class="o">@</span><span class="mi">1686787200</span> <span class="p">{</span><span class="c1">#213</span>
        <span class="n">date</span><span class="o">:</span> <span class="mi">2023</span><span class="o">-</span><span class="mo">06</span><span class="o">-</span><span class="mi">15</span> <span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="o">:</span><span class="mf">00.0</span> <span class="nf">UTC</span> <span class="p">(</span><span class="o">+</span><span class="mo">00</span><span class="o">:</span><span class="mo">00</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">+</span><span class="n">reservedAt</span><span class="o">:</span> <span class="nc">DateTimeImmutable</span> <span class="o">@</span><span class="mi">1685054767</span> <span class="p">{</span><span class="c1">#214</span>
        <span class="n">date</span><span class="o">:</span> <span class="mi">2023</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mi">25</span> <span class="mi">22</span><span class="o">:</span><span class="mi">46</span><span class="o">:</span><span class="mf">07.0</span> <span class="o">+</span><span class="mo">00</span><span class="o">:</span><span class="mo">00</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>As a next step, we can declare the attributes on all the commands or other objects we want to be mapped in the 
controllers. If we face another unmapped property, we saw how we can add a custom resolver for it.</p>

<p><br />
<small><small><small>
    Photo for social media by 
    <a href="https://www.pexels.com/photo/brown-framed-eyeglasses-on-white-printer-paper-beside-white-ceramic-mug-1684149/" target="_blank">Daria Obymaha</a>.
</small></small></small></p>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <p class="text"><small>
        Unless otherwise stated, the content of this blog is licensed under a <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
        </small></p>

      <p class="text" style="float: left;">
        <small>Built with <a href="http://jekyllrb.com" target="_blank">Jekyll</a></small>
      </p>

      <p class="text" style="text-align: right;">
        <small>Subscribe via <a href="/feed.xml">RSS</a></small>
      </p>
    </div>

  </div>

</footer>


  </body>

</html>
